
import semver from 'semver';
import { decodeBase64 } from '../utils/utils.js';
import { callGithubApi, mapEcosystemToQuery } from '../api/githubApi.js';

export const validateRequest = (req) => {
  if (!req.body || !req.body.ecosystem || !req.body.fileContent) {
    throw new Error('Missing required fields in request body');
  }

  if (req.body.ecosystem !== 'npm') {
    throw new Error('Currently only npm ecosystem is supported');
  }
};

const parseVulnerabilityData = (ecosystem, data) => {
  if (ecosystem === 'npm') {
    // Parse Github's vulnerability data format (assuming data follows the response structure)
    return data.data.data.securityVulnerabilities.nodes.map((node) => ({
      name: node.package.name,
      severity: node.severity,
      summary: node.advisory.summary,
      firstPatchedVersion: node.firstPatchedVersion ? node.firstPatchedVersion.identifier : null,
      vulnerableVersionRange: node.vulnerableVersionRange,
    }));
  } else {
    throw new Error(`Unsupported ecosystem: ${ecosystem}`);
  }
};

export const fetchVulnerabilities = async (ecosystem, packageName, callback) => {
  const query = mapEcosystemToQuery(ecosystem, packageName);
  const vulnerabilityData = await callGithubApi(query);
  const parsedVulnerabilities = parseVulnerabilityData(ecosystem, vulnerabilityData);
  callback(parsedVulnerabilities);
  //validate response
  // return response.data.data.securityVulnerabilities;
};
  
export const isVulnerable = (packageVersion, vulnerability) => {
  const cleanRange = vulnerability.vulnerableVersionRange.replace(/ /g,'').replace(',', ' ');
  return semver.satisfies(packageVersion, cleanRange);
}

const getVulnerablePackages = async (dependencies, ecosystem) => {
    const vulnerabilities = [];
    for (const packageName of Object.keys(dependencies)) {
      const packageVersion = dependencies[packageName];
      await fetchVulnerabilities(ecosystem, packageName, (parsedVulnerabilities) => {
        if (parsedVulnerabilities && parsedVulnerabilities.length > 0) {
          for (const vulnerability of parsedVulnerabilities) {
            if (isVulnerable(packageVersion, vulnerability)) {
              vulnerabilities.push({ ...vulnerability, version: packageVersion });
            }
          }
        }
      });
    }
    return vulnerabilities;
};

const parseFileContent = (ecosystem, content) => {
  if (ecosystem === 'npm') {
    return JSON.parse(content);
  } else {
    throw new Error(`Unsupported ecosystem: ${ecosystem}`);
  }
};

export const scan = async (req, res) => {
  try {
    validateRequest(req);
    const ecosystem = req.body.ecosystem;
    const decodedContent = decodeBase64(req.body.fileContent);
    const parsedContent = parseFileContent(ecosystem, decodedContent);
    const dependencies = parsedContent.dependencies || {};
    const vulnerabilities = await getVulnerablePackages(dependencies, ecosystem);
    res.json({ vulnerablePackages: vulnerabilities });
  } catch (error) {
    console.error(error);
    res.status(400).send(error.message);
  }
};
